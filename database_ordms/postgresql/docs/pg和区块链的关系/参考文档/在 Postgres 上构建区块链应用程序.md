https://www.timescale.com/blog/building-blockchain-apps-on-postgres//





数据库的时间维度是每个区块链的基本要素。没有它，区块链就无法运行：无法添加交易和区块。与区块链相关的数据本质上是时间序列数据。

在 Timescale，我们一直在寻找方法来展示时间序列数据不断扩大的覆盖范围。利用我们的 PostgreSQL 和 TimescaleDB 超能力，我们能够洞察世界上一切事物背后的数据。借助时间序列数据，我们不仅能够看到事物的现状，还能看到事物的变化和变化过程。衡量变化是更好地了解世界的重要组成部分。

在本文中，我们将介绍在 Postgres 上构建区块链应用程序的技巧和策略。我们还将介绍 Postgres 和 TimescaleDB 如何相互支持以创建更具动态的应用程序。

## 区块链数据是时间序列数据

区块链数据结合了许多不同类型的数据——[包括时间序列数据](https://www.timescale.com/blog/time-series-data/)。通过组合这些数据集，你可以获得很多价值。 

在过去的一篇博客文章中，我确实这样做了：我使用 PostgreSQL 分析了比特币（BTC）区块链，查看了交易量和 BTC USD 汇率，以了解它们之间的关联方式和原因。

![显示交易量和 BTC USD 汇率的折线图](https://www.timescale.com/blog/content/images/2022/12/Building-Blockchain-Data-Apps_img1.png)

我认为这种分析非常有趣，因为这是两个不同的数据集：一方面，你有交易量，你可以通过获取链上数据直接从区块链中获取，然后按每日或每周汇总所有交易；另一方面，你将这个数据集与加密货币数据相结合，其中包含 BTC USD 汇率。同样，这一切都发生在 PostgreSQL 数据库中。

## 区块链应用需要动态数据库

有些时间序列数据库不允许你在数据库中存储不同类型的数据集，因此你最终会在一个数据库中存储时间序列数据，而在另一个数据库中存储关系数据。要分析所有这些数据，你必须在应用程序层上将它们组合起来，众所周知，这可能是一个令人头疼的问题。

使用 TimescaleDB，因为我们是 PostgreSQL，您可以在数据库中存储各种数据：我们是一个通用数据库，但我们也针对时间序列（又名区块链数据）做了很多优化。

另一个可以用作数据应用程序数据库中的数据集的原始数据示例是这个。

![比特币交易数据的原始数据示例](https://www.timescale.com/blog/content/images/2022/12/Building-Blockchain-Data-Apps_img2.png)

原始形式的比特币交易数据

这是来自 BTC 区块链的数据，即链上数据。如您所见，我们有一个时间列（可让您将此数据集与其他数据集合并）、区块 ID、哈希大小、区块大小等。

看看这两个例子，你会注意到以下几点：

- 它们被视为区块链数据，因为它们包含有关区块链的信息。
- 这两个数据集都带有时间戳——它们是时间序列数据。
- 由于区块链在技术上是时间序列数据库，因此它们是仅追加的：您可以向区块链添加新记录或区块，但永远不能修改历史区块。
- 区块链大数据是实时数据，也就是说，当您阅读这些文字时，区块链上正在处理新数据。

因此，如果您正在构建实时数据应用程序，则必须确保您的数据库能够处理此类数据，而这对于分析数据库来说并不容易。这是用户尝试 TimescaleDB 的主要原因之一：它是一个关系数据库，但在分析和历史数据方面表现非常出色。

最后，区块链数据与其他数据集相连。即使你在企业工作，你也可以提取内部数据并将其与区块链公共数据相结合。

### 基本数据库功能

现在让我们看看数据库必须具备哪些功能才能无缝处理区块链数据。 

- 可扩展至时间序列数据。如前所述，区块链数据是时间序列数据。您需要一个能够处理它的数据库。
- 历史和实时功能。例如，实时查询与历史查询有很大不同。如果您想在面向客户的应用程序上提供实时数据，那么在同一数据库中做到这一点可能非常困难。 
- 避免数据孤岛。如果你要合并不同的数据集，这一点非常重要。如果你开始探索 BTC 区块链或加密货币数据，一段时间后你可能会想将它们与另一个数据集合并。

## PostgreSQL 改变了区块链存储领域的格局

要探索比特币交易的世界，您需要确保您的数据库基础设施可靠、可扩展且可维护——特别是如果您在这些数据之上构建数据应用程序。

使用 PostgreSQL 存储区块链数据为您提供了可靠的基础，可以跟上区块链的持续运行特性。 

您需要一个架构来将任何内容存储在 TimescaleDB 等关系数据库中。让我们看一个简单而有效的架构，您可以开始存储比特币交易。

### 比特币交易的数据库模式

本博文收集的数据集使用了 Blockchair 的[数据转储](https://gz.blockchair.com/bitcoin/transactions/?ref=timescale.com)。这些数据文件与实际区块链上的数据一样，包含的数据字段比本文介绍的要多。但此示例架构仍然提供了几个数据字段（例如交易权重、输出、费用等），可以帮助您入门并产生见解。

尽管如此，如果您决定分析博客文章中未涉及的数据字段，该模式有一个详细的 JSONB 列，用于存储所有附加信息。

数据字段说明：

| 场地        | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| 时间        | 交易时间戳                                                   |
| 区块 ID     | 区块 ID                                                      |
| 哈希        | 交易的哈希ID                                                 |
| 尺寸        | 交易大小（KB）                                               |
| 重量        | 交易规模（以重量单位计算）                                   |
| is_coinbase | 矿工收益交易                                                 |
| 总输出量    | 交易价值以 Satoshi (sat) 为单位                              |
| 输出总美元  | 交易价值（以美元计）                                         |
| 费用        | 交易费（单位：聪）                                           |
| 费用_美元   | 交易费（美元）                                               |
| 细节        | 有关交易的其他详细信息（例如，input_total、lock_time、fee_per_kwu 等） |

数据库架构：

```sql
CREATE TABLE transactions (
   time TIMESTAMPTZ,
   block_id INT,
   hash TEXT,
   size INT,
   weight INT,
   is_coinbase BOOLEAN,
   output_total BIGINT,
   output_total_usd DOUBLE PRECISION,
   fee BIGINT,
   fee_usd DOUBLE PRECISION,
   details JSONB
);
 
SELECT create_hypertable('transactions', 'time');

      
    
```

复制

这种模式大大简化了数据集的分析，但仍为未来的更改留下了空间，以防您发现详细的数据字段有用；它们仍然可通过 JSONB 列获得。

该`create_hypertable`函数将常规 PostgreSQL 表转换为[TimescaleDB 超表](https://docs.timescale.com/timescaledb/latest/how-to-guides/hypertables/?ref=timescale.com)，以根据时间戳列对表进行分区，从而优化时间序列数据的查询和提取 - 同时表现得就像常规 PostgreSQL 表一样。

## 使用索引来扩展区块链应用程序

为了使您的数据库具有“区块链规模”，您需要在 PostgreSQL 和 TimescaleDB 中应用一些优化策略，以便在维护和查询数据时享受令人满意的体验。

使用超表存储事务为简单且可扩展的时间序列存储奠定了基础。TimescaleDB 是 PostgreSQL 数据库，它允许您使用所有 PostgreSQL 优化策略（例如索引）以及 TimescaleDB 功能（例如连续聚合），以充分利用这两种工具。

总之，如果您使用使 PostgreSQL 在关系数据库领域中脱颖而出以及使 TimescaleDB 在时间序列领域中脱颖而出的功能，您就可以在数据库中获得最佳体验。

让我们从索引开始。

### B-树索引

当您创建超表时，TimescaleDB 会自动在表的时间戳列上添加 B 树索引。这已经改善了大多数按时间列过滤的查询。

例如，您可以这样做来查找过去两周内交易费高于交易价值的最新交易：

```sql
SELECT
 time,
 hash,
 fee*0.00000001 as fee_btc,
 output_total*0.00000001 as value_btc,
 output_total_usd as value_usd
FROM transactions
WHERE "time" > NOW() - INTERVAL '2 weeks'
ORDER BY fee_btc DESC

      
    
```

复制

![最昂贵的交易（按 BTC 支付的费用）](https://www.timescale.com/blog/content/images/2023/10/blockchain-postgres-analysis-img-3.png)

最昂贵的交易（按 BTC 支付的费用）

仅通过使用 TimescaleDB，此查询的性能就立即优于常规 PostgreSQL。在底层，TimescaleDB 通过使用索引并排除定义时间段之外的块来加快此查询的速度。您还可以根据计划编写的查询类型决定添加更多索引。

例如，如果您计划构建一个分析单个比特币交易的数据应用程序，则可以通过向哈希列添加索引来获得更好的查询性能。

区块链上的每笔交易都有一个哈希值，即一个 64 个字符长的字符串，用作交易的唯一标识符。如果您的应用程序用户搜索特定交易以了解更多信息，他们应该使用此列在表中查找交易。

```sql
SELECT * FROM transactions
WHERE hash = '94fb53b99dd2cb7ccf26745c908eebd7c01cb8c19fb84819b796beb7750b0cb8'

      
    
```

复制

![img](https://www.timescale.com/blog/content/images/2023/10/blockchain-postgres-analysis_img-4.png)

您可以通过向哈希列添加哈希索引来加快此查询的速度。

```sql
CREATE INDEX hash_idx ON public.transactions USING HASH (hash)

      
    
```

复制

如果您存储了超过一亿行交易，并且想要按哈希列进行筛选，那么此索引必不可少。它能够将运行 10 秒或更长时间的查询转变为在不到一秒内完成的查询。

您还可以通过在时间和哈希列上添加唯一索引来确保不会意外插入重复记录。

```sql
CREATE UNIQUE INDEX time_hash_idx ON public.transactions (time, hash)

      
    
```

复制

## 连续聚合可以加速查询

[连续聚合](https://docs.timescale.com/timescaledb/latest/how-to-guides/continuous-aggregates/?ref=timescale.com)是时间序列数据的物化视图。它们是为时间序列数据而设计的，并提供了一种刷新和查询存储值的有效方法。它们甚至存储实时数据。在设置适当的索引后，这是您可以进行的最重要的优化，以使您的查询速度飞快。

对于时间序列数据，用户通常会根据时间汇总数据，从而创建所谓的“[时间段](https://docs.timescale.com/timescaledb/latest/how-to-guides/time-buckets/?ref=timescale.com)”。时间段可让您分析事物随时间的变化情况。以比特币区块链为例，它可让您查看交易费用、交易大小、区块权重等随时间的变化情况。

这些聚合的时间序列查询通常是由仪表板或某些面向用户的应用程序执行的重复查询。因此，尽可能快地执行这些查询以提供流畅的用户体验非常重要。这正是 TimescaleDB 的连续聚合将要做的事情。

您可以设置连续聚合来预先聚合和实现数据库内的信息，并将查询执行时间从几秒甚至几分钟缩短到亚秒级。

即使在分析超过 1.5 亿行的大型区块链数据库时，仅使用索引和连续聚合就可以实现出色的性能和亚秒级的查询执行速度。

让我们看一下用于存储和提供区块链数据的连续聚合设置的示例。

### 区块链分析的连续聚合的三个示例

[正确设置的连续聚合](https://www.timescale.com/learn/real-time-analytics-in-postgres?ref=timescale.com)可以加快查询速度并使查询更易于编写。让我们选择数据的三个方面作为连续聚合定义的基础：

- 交易
- 区块
- 矿工（收入）

#### 交易

区块链旨在记录信息，而无需更新历史数据。对于比特币来说，区块链只是一个包含交易信息的数字公共账本。简而言之，交易会告诉你谁向谁发送了多少金额，以及技术细节。

每笔交易至少有一个输入和输出字段，用于指示使用哪个地址将 BTC 发送到哪个地址。 同一笔交易中可以有多个“发送者”和“接收者”。

交易不是单独开采的；它们是成组开采（添加到区块链）的。这些组被称为区块。

#### 区块

区块链由区块组成。从数据分析的角度来看，这些区块非常重要，原因有很多。矿工根据他们添加到区块链的区块获得收入。每个区块都有一个唯一标识符，称为 block_id。在[SegWit](https://en.wikipedia.org/wiki/SegWit?ref=timescale.com)之前，一个区块的大小限制为 1 MB。在 SegWit 之后，网络中增加了一种称为重量单位的新度量标准，一个区块的新限制变为 400 万个重量单位。

#### 矿工

对于任何区块链来说，矿工都是必不可少的。他们让网络保持正常运行。矿工通过 BTC 获得激励，以维护和验证区块链上的区块顺序。就比特币而言，矿工的收入来自两个来源：区块奖励和交易费。区块奖励目前为 6.25 BTC，每开采 210,000 个区块（约每四年）奖励减半。区块链用户每次提交交易时都要支付交易费。

通过持续聚合和自动化策略，您可以简化今后的工作：

- 通过实现（将结果保存到磁盘）您经常使用的基于时间的聚合，您可以节省大量资源，这意味着数据库不需要在查询时重新计算信息。
- 由于刷新策略，视图会自动维护，因此您只需专注于分析数据。
- 实时聚合变得简单，因为连续聚合默认结合了物化表和底层超表的查询结果（节省了您`UNION`在所有查询中执行的操作）。
- 您可以按计划压缩或删除连续聚合中的数据，或者删除超表中的底层原始数据并将下采样的数据保留在连续聚合中。

设置索引和连续聚合作为优化后，您可以专注于分析数据并产生见解，同时获得快速、简单的查询体验。

现在您知道我们使用了哪些功能来使用 PostgreSQL 和 TimescaleDB 分析数据，让我们看看其背后的思考过程。

## 为什么 TimescaleDB 是区块链应用的最佳数据库

当然，我们认为我们的数据库是最好的选择。请让我们有机会通过这个简短的架构概述来解释原因。

### 存储层

TimescaleDB 建立在 PostgreSQL 之上。我们不是 PostgreSQL 类产品，也不是 PostgreSQL 的分支产品。我们是 100% 的 PostgreSQL，因为我们是一个扩展，这意味着我们的存储层与 PostgreSQL 中的存储层相同。

### 架构管理

然而，我们通过引入自动分区修改了 PostgreSQL 的模式管理。非常简单，我们根据时间列对数据进行分区，提供长期可扩展性和一些其他重要优势。

例如，假设您想要删除一年或两年的数据。在关系数据库中，您可以执行 DELETE 语句，逐行删除行。使用自动分区（我们称之为块机制），您可以设置数据保留策略，并要求数据库仅删除一年或一年以上的数据。然后，数据库将删除表，由于块机制，该过程更快、更高效。

### 查询规划器

如果您按时间过滤或按时间聚合，我们有时会修改查询规划器，尤其是对于时间序列数据，这是您在分析区块链数据时通常会做的事情。因此，也许您正在创建一天的时间段或五分钟的时间段：无论哪种方式，我们都将提供一些功能，使流程无缝流动并提高性能。

### SQL 接口

我们是完整的 SQL，这意味着 PostgreSQL 数据库中的所有功能都可以在 TimescaleDB 中运行。我们不会从 PostgreSQL 中拿走任何东西；我们只是添加了许多新功能，例如时间序列函数。

这些将帮助您分析时间序列数据和区块链数据。例如，我们有一些函数可以帮助[您创建构建蜡烛图所需的值](https://www.youtube.com/watch?v=08CydeL9lIk&ref=timescale.com)。因此，您可以从行数据中生成数据库中的开盘价、最高价、最低价和收盘价。

我们还提供许多其他可用于分析区块链数据的统计函数：